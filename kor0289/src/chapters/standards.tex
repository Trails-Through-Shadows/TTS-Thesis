\chapter{Standardy využívané pro tvorbu API}
V této kapitole si porovnáme a představíme různé architektury které se používají pro tvorbu \gls{api}.
Hlavní nástroje co si představíme jsou na trhu a v nějaké míře se používají jsou REST, Webhooky a SOAP

\subsection*{Úvod}
\gls{api} je universální komunikační rozhraní mezi aplikacemi, které můžeme použít pro více druhů koncových aplikací. Vlastně to je soubor definicí, protokolů a občas i nepsaných pravidel.

\section{REST}
\gls{rest} což můžeme přeložit jako reprezentační stavový přenos. Je to nejčastěji používaná architektura API. REST byl původně vytvořen jako vodítko jak komunikovat na velké síti jako je Internet. Popularita REST API je z důvodu jednoduchosti implementace a provádění změn. Taky je velice výkonné a přehledné i na velkých projektech.
Webové služby které využívají architekturu REST pro API jsou nazývána RESTful webové služby. Pojem RESTful API většinou označují RESTful web API. Nicméně tyto dva pojmy se mohou zaměňovat nezávisle na sobě.

Níže si popíšeme základní principy REST API

\subsection{Uniform interface}
Klíčová vlastnost RESTful služeb. Indikuje, že server předává a přijímá data v určitém specificky strukturovaném formátu. Nejčastěji v JSON.

Jednotné rozhraní by mělo dodržovat tyto pravidla\
\begin{enumerate}
    \item Požadavky by měly identifikovat zdroje.
    \item Klient je schopen z přijmutých dat provést úpravu nebo smazání dat.
    \item KLient je schopen přijmout metadata o tom jaký typ zprávy jde a tím pádem jak tuto zprávu zpracovat.
    \item Klient může dostat informace o ostatních datech které se vážou k tomuto požadavku. (HATEOAS)
\end{enumerate}

\subsection{Stateless (bezstavový)}
Komunikační metoda kdy server obslouží každého klienta zvlášť a nezávisle na jeho předchozích akcí. Klienti mohou dávat požadavky nezávisle na pořadí. Server si tudíž neuchovává data o klientech.

\subsection{Layered system}
Styl architektury kdy klient se může připojit i k jiným zprostředkovatelům a pořád dostane odpověď od serveru. Servery taktéž se mohou dotazovat na jiné servery při zpracovávání požadavků od klienta. Tímto způsobem můžeme mít více vrstev jako je bezpečnostní vrstva, aplikační vrstva či business logika.
Tyto vrstvy jou stále pro klienta neviditelné.

\subsection{Cacheability}
Velká výhoda je že RESTful webové služby podporují cache. Vyžaduje aby Server tyto data označil jako cacheable či non-cacheable. Při stejném dotazu klienta vícekrát za nějaký krátký čas se použijí již stáhnutá data. Například pro obrázky. Tím se docílí o hodně rychlejší odezvy.

\subsection{Code on demand}
Dnes již málo používané, REST API může vrátit kód co má klient vykonat. Tím může server rozšířit klienta o funkcionalitu. Např. při validaci formuláře se ihned může zobrazit chybová hláška.



\subsection{Jak funguje RESTful API} % TODO reformat this bcs its not the same as rest
RESTful API funguje na protokolu HTTP/S. Nejdříve klient pošle request serveru podle dokumentace konkrétní API. Server poté zkontroluje zda je klient oprávněn tuto operaci provést. Poté zpracuje požadavek a pošle odpověď s příslušným stavovým kódem.

\subsection{Co obsahuje request na RESTful API} % TODO reformat this bcs its not the same as rest
Požadavky na RESTful API musí obsahovat následující
\subsubsection{URI}
Unique resource identifier je unikátní identifikátor pro určité data. V RESTful API nejčastěji URL, které se taktéž říká endpoint. URL specifikuje cestu k daným datům.
\subsubsection{Metoda}
Jak již bylo předtím zmíněno, RESTful API typicky používá HTTP/S protokol. V tomto protokolu máme několik možností metod.

\begin{description}
    \item[GET] - Požadavek pro získání dat na základě parametrů v URL. Opakované volání vrátí vždy stejný výsledek.
    \item[POST] - Požadavek pro vložení kompletně nových dat. Data pro vložení se zároveň vloží do message body. Zde se s opakovaným voláním vloží zase znovu ta stejná data.
    \item[PUT] - Požadavek pro úpravu dat. Data pro přepsání dat jsou vložena do message body. Opakované volání vrátí vždy stejný výsledek.
    \item[DELETE] - Požadavek pro smazání dat.
    \item[PATCH] - Požadavek pro částečnou úpravu dat. Není třeba posílat celý objekt.
\end{description}

\subsection{Co obsahuje odpověď od serveru}
REST principy vyžadují aby v odpovědi byli obsaženy tyto věci.
\subsubsection{Stavové kódy}
Stavovými kódy lehce zjistíme jak daný požadavek dopadl. Zda-li úspěšně nebo se vyskytla chyba. Proto je důležité je správně používat. Stav je trojmístné číslo a podle počátečního čísla poznáme typ odpovědi. Kód začínající 2xx značí úspěch, 4xx chybu na straně klienta, 5xx chybu na straně serveru a v neposlední řadě 3xx což označuje přesměrování URL.
Nejčastěji využívané kódy jsou tyto:

\begin{description}
    \item[200 OK] - Vše proběhlo v pořádku.
    \item[201 Created] - vše proběhlo v pořádku při požadavku POST (data byla zapsána).
    \item[400 Bad Request] - Server nepřijímá tyto data. Chyba na straně uživatele.
    \item[401 Unauthorized] - Klient nemá potřebná oprávnění pro vykonání této akce.
    \item[404 Not Found] - Adresa či data na které se klient dotazuje neexistují.
    \item[500 Internal Server Error] - Obecná chyba na straně serveru.
\end{description}

\subsubsection{Message body}
Ať už požadavek či odpověď, mohou obsahovat další data. Nikde není specifikováno v jakém formátu budou. Toto rozhodnutí je čistě na programátorech. Ale nejčastěji se používá JSON nebo XML. Jedná se o čistě textovou reprezentaci dat.

Například při požadavku GET pro uživatele s ID 1 server vrátí v message body JSON
\begin{verbatim}
	{"name":"Jožko Mrkvička", "age":30}
\end{verbatim}
Tento objekt reprezentuje uživatele který se jmenuje Jožko Mrkvička a je mu 30 let.

\subsubsection{Headers}
V hlavičkách jsou přídavné informace. Ať už kódování body, datum a čas, typ obsahu v body. Nebo na straně klienta autorizaci jako třeba session key.

\subsection{Shrnutí}
Dnes nejpoužívanější architektura pro API. Je velice flexibilní, jednoduchý a programátor si může sám určit který formát pro přenos dat bude používat. Je také velice intuitivní a samopopisný takže je jeho učící křivka rychlá. Nicméně kvůli textové podobě přenosu dat může být pomalejší než architektury používající binární soubory ale díky podpoře cache se může optimalizovat.

\section{SOAP}
SOAP neboli Simple Object Access Protocol je další z mnoha architektur API. Taktéž využívá aplikační vrstvu HTTP/S ale klidně může využívat jiné aplikační protokoly. Využívá pro přenos dat XML formát.

Mám se tady rozepsat o tom co je to XML? u JSONU jsem to taky neudělal. Možná tu i rozepíšu JSON.

\subsection{Charakteristika}
SOAP má tři základní stavební kameny které definují zprávy.
\begin{description}
    \item[Envelope] Zapouzdřuje celou právu. Určuje jakou strukturu má zpráva mít a jak ji zpracovat
    \item[Header] Obsahuje informace o zprávě. Například autentizační údaje
    \item[Body] Samotná data. Obsahují dotazující informace a informace s odpovědí.
    \item[(Fault message)] Může a nemusí obsahovat. Obsahuje kód chyby, actor, string a detail
\end{description}

Z pohledu klienta je podobné jako RESTful architektura. Klient vygeneruje požadavek ve formátu XML. Poté vygenerovaný SOAP požadavek klient pošle na SOAP server a ten následně vyvolá požadovanou aplikaci běžící na serveru. Odpověď z aplikace s požadovanými daty, parametry a hodnotami přepošle nejdříve SOAP request handleru a následně je odpověď poslána klientovi.

\subsection{Výhody}
\begin{description}
    \item[Nezávislost na platformě] SOAP může běžet na jakémkoli operačním systému či síťovém protokolu. Což umožňuje komunikaci mezi různými jazyky jak na Windows tak i Linux.
    \item[HTTP protokol] Primárně se používá HTTP protokol. To je výhoda že se nemusí upravovat firewall. I když funguje na jakémkoli ale tam by se mohlo stát že by se musela upravovat komunikační infrastruktura.
    \item[Zabezpečení] má vlastní rozšíření Web Services security. Podporuje funkce jako x.509 certifikáty, vlastně-definované tokeny, Kerberos tickety a uživatelské ID/heslo pověření. Taktéž možnost HTTPS přidává vrstvu šifrování.
\end{description}

\subsection{Nevýhody}
\begin{description}
    \item[Rychlost] kvůli vysokému zabudovanému zabezpečení a kvůli serializaci do XML je tento protokol velice pomalý s porovnáním s ostatními
    \item[Složitost] vzhledem k podpoře více protokolů se nemůže využít funkcí jednotlivých protokolů jako třeba u RESTful cachování a Uniform interface
\end{description}

\subsection{Shrnutí}
Vzhledem k masivnosti a rychlosti tohoto protokolu se od něj upouští aby se optimalizovala rychlost tvořených API. To ale neznamená že se už nepoužívá. Díky jeho bezpečnosti je stále využíván bankami, E-komercí, ve zdravotnicví a všude kde je primární apel na bezpečnost.

\section{GraphQL}
GraphQL byl vyvinut Facebookem dnes již Metou. Je to open-source query language a runtime určený pro API. GraphQL poskytuje deklarativní získávání dat kdy si klient přesně určí jaká data potřebuje. Tím pádem je velice šetrný k datům a není třeba mít více endpointů pro různě rozdělená či vyplněná data. Díky tomu že GraphQL může načítat data z různých zdrojů, není závislý na konkrétní databázi či úložišti.

\subsection{Design}
Je postaven kolem modelu \textit{dostanu přesně to o co si řeknu} bez nadměrného nebo nedostatečného načítání. To celkově zrychluje přenos dat. Využívá typový systém pro definici prostředků které nazýváme schéma. při každém požadavku je query zkontrolována oproti schématu a poté vykonána. Server potom vrátí data ve stejném formátu jako byla query typicky jako JSON.

\begin{listing}[h!]
    \inputminted[]{ts}{resources/code/playertype.gql}
    \caption{Příklad schématu v GraphQL}
    \label{code:gql_type}
\end{listing}

\begin{listing}[h!]
    \inputminted[]{graphql}{resources/code/playerquery.gql}
    \caption{Příklad query v GraphQL}
    \label{code:gql_querry}
\end{listing}

\subsection{Datové typy}
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
je jich dost a je tu hoafo co popisovat uvidíme jak dlouhé tohle celkově bude


\begin{listing}[h]
    \inputminted[]{graphql}{resources/code/types.example.gql}
    \caption{Příklady datových typů}
    \label{code:gql_datatypes}
\end{listing}

\begin{description}
    \item[Type system] - Základ typového systému je Query. Ta určuje jaké objekty mohou být získány (\coderef{code:gql_type} řádek 29). Vlastnosti ve výchozím stavu mohou nabývat hodnotu \texttt{null}. Z datový typ se může dát vykřičník abychom označili že tato hodnota nikdy nebude \texttt{null}. \textbf{dále datové typy zde}
    \item[Queries] - Query přesně definuje jaká data klient potřebuje. Za pomocí \coderef{code:gql_querry} dostaneme téměř stejný výsledek jako \coderef{code:json_player} akorát celý JSON bude zabalený do \texttt{"characters": {}}
    \item[Mutations] - Dovoluje pozměnění, smazání, nebo přidání dat ze strany klienta. Po provedení GraphQL vrátí upravená data. Taktéž definuje jaký tvar vrácená data budou mít. \coderef{code:gql_datatypes} řádek whatever kolik to bude.
    \item[Subscriptions] - Podpora posílání aktualizací v reálném čase. Dotaz je velice podobný jako u query (\coderef{code:gql_datatypes} řádek subsection)
\end{description}

\section{Porovnání a shrnutí} %TODO předělat tohle jsou jen myšlenky co tu dát
\textbf{předělat tohle jsou jen myšlenky co bych měl říct}

Porovnání dělám na základě vlastních úsudků co bude po naše účely nejlepší styl API. Nepředpokládáme nějaké velké vytížení co se dotazů na API týče. Taktéž potřebujeme něco poměrně jednoduchého a lehce pochopitelného. Zabezpečení není priorita protože bez fyzické hry je API nevyužitelné. Taktéž když budeme potřebovat protivníky nebo hrací plán tak budeme chtít vědět vše o nich a ne jen část dat. Dá se předpokládat že pokud by hra byla v komerci úspěšná tak odhadujeme 1.000.000 kopií. -> 10000per sec? takže CDN a cajk asi idk.


\endinput