\chapter{Form치ty vyu쮂셨aj칤c칤 se v API}
V t칠to kapitole budou pops치ny p콏edev코칤m dva z치kladn칤 form치ty dat kter칠 jsou st치le aktivn칤 -- JSON a XML.


\subsection*{Serializace a deserializace} %TODO cote https://www.baeldung.com/cs/serialization-deserialization
Serializace a deserializace jsou d콢le쬴t칠 koncepty v programov치n칤. Umo쮄갓j칤 ukl치dat, p콏en치코et a znovu sestavit data. Pou쮂셨aj칤 se celou 콏adu v캩c칤, jako je ukl치d치n칤 objekt콢 do datab치ze, pos칤l치n칤 dat po s칤ti a nebo pro 칰캜ely mezipam캩콘i.

Objekt m치 3 z치kladn칤 vlastnosti: identitu, stav a chov치n칤. Stav reprezentuje jednotliv치 data objektu.
\textbf{Serializace} je proces p콏ev치d캩n칤 stavu objekt콢 do proudu byt콢 co mohou b칳t kdekoliv ulo쬰ny nebo posl치ny. Tento proud m콢쬰 b칳t pot칠 zase rekonstruov치n do p콢vodn칤ho objektu. Pro serializaci si v코ak mu칤me vybrat form치t dat. Jako t콏eba JSON nebo XML. Ov코em pou쮂셨치 se i bin치rn칤 reprezentace dat. Tato reprezentace se 캜asto vyu쮂셨치 pro v칳konnostn칤 pot콏eby, proto쬰 jsou typicky rychlej코칤 na z치pis a 캜ten칤. Jejich nev칳hoda ale je, 쬰 nejsou 캜lov캩kem 캜iteln칠.

\textbf{Deserializace} je opa캜n칳 proces od serializace. Tedy p콏eveden칤 proudu byt콢 zp치tky do objektu.

Jednou z nev칳hod serializace a deserializace jsou vysok칠 n치roky na v칳kon. M콢쬰to trvat nezanedbateln칠 mno쬽tv칤 캜asu. Zvl치코콘 u velk칳ch objekt콢. Za zm칤nku stoj칤 i fakt, 쬰 ne v코echny objekty mohou b칳t serializov치ny. Jako t콏eba sockety nebo file handlery.


\section{JSON}
JavaScript Object Notation neboli JSON je form치t, kter칳 je odvozen z Javascriptu, nicm칠n캩 mnoho dne코n칤ch jazyk콢 u m치 serializaci do JSONu zabudovanou intern캩. Jedn치 se o textov칳 form치t z치pisu objekt콢, kter칳 je dob콏e 캜iteln칳 캜lov캩kem. Ukl치d치 data do p치r콢 \textbf{key:value} kdy key je kl칤캜 a value hodnota, kter치 je pod n칤m ulo쬰n치, obvykle m콢쬰 j칤t o 캜칤slo, textov칳 콏et캩zec, pole nebo i dal코칤 objekt. Znaky v JSONu mus칤 b칳t v k칩dov치n칤 UTF-8, ale form치t podporuje i speci치ln칤 znaky pokud jsou escaped, jako p콏칤klad m콢쬰me uv칠st znaky \verb |\uD83D\uDE10| nebo \textit{neutral-face}. JSON je vyu쮂셨치n prim치rn캩 k v칳m캩n캩 dat mezi webov칳mi aplikacemi a servery, ale d치 se pou쮂셨at i pro jednoduch칠 datab치ze. M치 prost치 ale zato striktn칤 pravidla a tud칤 je jednoduch칠 zkontrolovat jeho spr치vnost. Jeden z jeho nedostatk콢 je, 쬰 nem치 podporu koment치콏콢 oproti XML, kter칠 tuto podporu m치. %\textbf{ TODO odkaz n캩kde na iso normu https://www.iso.org/standard/71616.html} %TODO bibtech na iso normu plus d치t emoji 游땛 t콏eba xetex ale to se pak cel칠 rozbije


\subsection{Pravidla}
\textbf{Key} neboli kl칤캜 dan칠ho objektu je v쬯y string a reprezentuje n치zev ur캜it칠ho atributu. \textbf{Value} p콏edstavuje hodnotu, kterou tento atribut nab칳v치 a m콢쬰 b칳t datov칠ho typu text, 캜칤slo, logick치 hodnota, null, dal코칤 objekt 캜i pole. Jednotliv칠 atributy jsou v쬯y odd캩leny 캜치rkou. Jako p콏칤klad je uveden JSON objekt z API modelov칠 hry, kter칳 popisuje hr치캜e, jeho vlastnosti a jeho rasu, reprezentovanou jako vno콏en칳 objekt.

\begin{listing}[H]
  \inputminted{json}{resources/code/standards/player.json}
  \caption{P콏칤klad JSON objektu}
  \label{code:json_player}
\end{listing}

V tomto JSONu m콢쬰me vid캩t v코echno, s 캜칤m se u tohoto datov칠ho form치tu m콢쬰me setkat. Jako prvn칤 atribut, tento objekt m치 \verb|"id":4|, kde id je kl칤캜 a 4 je 캜칤slo -- to zna캜칤, 쬰 tento objekt m치 sv콢j unik치tn칤 identifik치tor 4.

Na 6 콏치dku m콢쬰me vid캩t atribut \verb|"title":"Elf"|. Value je v tomto p콏칤pad캩 text, kter칳 pozn치me podle zaobalen칤 uvozovek. Tento 콏치dek v kontextu cel칠ho objektu zna캜칤, 쬰 se jedn치 o rasu postavy, kter치 m치 n치zev \textit{Elf}.

Atribut, kter칳 tento text zaobaluje, je \texttt{"race"}. Jedn치 se o p콏칤klad objektu, v tomto p콏칤pad캩 rasy, kter치 m치 sv칠 vlastnosti reprezentovan칠 pr치v캩 t칤mto objektem.

V atributu \texttt{"effects"} se nach치z칤 pole objekt콢. V tomto p콏칤pad캩 to jsou objekty obsahuj칤c칤 kl칤캜 s id rasy a jej칤m efektem, ke kter칠mu je p콏id치na tak칠 informace o tom, od jak칠 칰rovn캩 je tento efekt zp콏칤stupn캩n. Podobn캩 tak na 콏치dku 26 je jako value kl칤캜e \texttt{inventory} pole textov칳ch 콏et캩zc콢 zn치zor켿uj칤c칤 p콏edm캩ty, kter칠 hr치캜 vlastn칤.

D치le si m콢쬰me pov코imnout atributu \texttt{clazz} na 콏치dku 3, kter칳 m치 hodnotu \texttt{null}. To n치m zna캜칤, 쬰 tento konkr칠tn칤 kl칤캜 u objektu zat칤m nic neobsahuje. M콢쬰 se st치t 쬰 jen nebyl p콏i콏azen a v budoucnu n캩jakou hodnotu dostane.

A nakonec zde m치me na 콏치dku 29 atribut \texttt{dead} s hodnotou \texttt{false}. Tato hodnota zna캜칤 logickou hodnotu, kter치 m치 datov칳 typ boolean. V na코em p콏칤pad캩 se jedn치 o vlastnost, kter치 n치m 콏칤k치, zda je hr치캜 mrtv칳 (\texttt{true}) 캜i nikoli (\texttt{false}).


\section{XML}
Extensible Markup Language je jazyk prim치rn캩 ur캜en칳 na serializaci a p콏en치코en칤 dat, kter칳 je podobn캩 jako JSON 캜iteln칳 i 캜lov캩kem. Z치kladn칤 stavebn칤 blok je node, atributy jsou ulo쬰ny do p치r콢 kter칳m 콏칤k치me tagy. Za pomoc칤 sv칠 deklarace podporuje ur캜en칤 k칩dov치n칤 a r콢zn칠 verze. D칤ky XML Schema definition tak칠 podporuje celou 콏adu datov칳ch typ콢 a oproti JSONu podporuje i koment치콏e. Standardy spravuje spole캜nost W3C. %\textbf{fest fajny odkaz na w3c specifikaci do bibtex} %TODO bibtech na w3c


\subsection{Pravidla}
Na za캜치tku dokumentu je v쬯ycky XML deklarace, kter치 ur캜uje, o jakou verzi se jedn치 a jak칠 maj칤 znaky k칩dov치n칤.
Samotn치 data jsou zaznamen치na pomoc칤 p치rov칳ch tag콢, dohromady naz칳van칳m \textbf{element}, kter칠 se zapisuj칤 jako po캜치te캜n칤 (\texttt{<character>}) a ukon캜ovac칤 (\texttt{</character>}) tag, kde \textit{character} zna캜칤 n치zev atributu, podobn캩 jako \textbf{key} u JSONu. Hodnota atributu se p칤코e bu캞 mezi po캜치te캜n칤 a ukon캜ovac칤 tag, nebo p콏칤mo do tagu samotn칠ho (\texttt{<character id=4>}). Tzv. \textit{procesory} analyzuj칤 XML dokumenty a pos칤laj칤 d치le strukturovan치 data aplikaci, kter치 se vyu쮂셨치. Procesory m콢쬺u b칳t jak validuj칤c칤 tak nevaliduj칤c칤, p콏i캜em validuj칤c칤 mus칤 nalezenou chybu nahl치sit ale po콏치d mohou v parsov치n칤 pokra캜ovat.

\begin{listing}[H]
  \inputminted{xml}{resources/code/standards/player.xml}
  \caption{P콏칤klad XML dokumentu i se sch칠matem}
  \label{code:xml_player}
\end{listing}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{figures/type-hierarchy.png}
  \caption{Hierarchie datov칳ch typ콢 v XML schema}%\cite{british_museum_2021}}
  \label{fig:xml_datatypes}
\end{figure}
%TODO odkaz na obr치zek v코ech mo쬹칳ch datov칳ch typ콢 https://www.w3.org/TR/xmlschema-2/type-hierarchy.gif a p콏칤mo ta str치nka https://www.w3.org/TR/xmlschema-2/#built-in-datatypes


%TODO n캩jak칳 odkaz p캩kn칳 nebo tak n캩co na 
Tento XML dokument reprezentuje stejnou strukturu jako JSON popsan칳 v칳코e. Oproti n캩mu je v코ak roz코칤콏en o sch칠ma, ve kter칠m m콢쬰me ur캜it jeden z mnoha datov칳ch typ콢 \ref{fig:xml_datatypes} pro ka쬯칳 element (콏치dek 3) 캜i atribut (콏치dek 6 a 7). Kdy nen칤 sch칠ma specifikov치no, v코echny datov칠 typy jou br치ny za text. Velk치 zm캩na oproti JSONu tak칠 spo캜칤v치 v tom, 쬰 v칤me, o jak칳 objekt se jedn치 (콏치dek 23 a 48) -- m칤sto oby캜ejn칳ch slo쬰n칳ch z치vorek zde m치me element se jm칠nem \textit{character}, co je informace, kterou JSON neposkytuje.


\section{Shrnut칤}
Te캞 byly p콏edstaveny p콏칤padn칠 technologie co bychom mohli pou쮂셦 jako form치t pro serializaci a deserializaci. Jak tyto technologie funguj칤, jak vypadaj칤 a jejich v칳hody a nev칳hody.

\begin{table}[h]
  \centering
  \begin{tabular}{|l|c|c|c|c|}
    \hline
           & 캛itelnost & Jednoduchost & Rychlost & Skladnost \\
    \hline
    JSON   & 1         & 1            & 2        & 3         \\
    \hline
    XML    & 2         & 3            & 4        & 4         \\
    \hline
    Binary & 5         & 4            & 1        & 1         \\
    \hline
  \end{tabular}
  \caption{Porovn치n칤 JSON, XML a Binary }
  \label{tab:formats_comparison}
\end{table}

\tableref{tab:formats_comparison} n치m srovn치v치 r콢zn칠 technologie podle na코ich p콏칤padn칳ch po쬬davk콢. \footnote[1]{Zn치mkov치n칤 jsem prov치d캩l 캜ist캩 podle vlastn칤ho uv치쬰n칤 co bude pro na코e pou쬴t칤 nejvhodn캩j코칤} \footnote[2]{Zn치mkov치n칤 je od 1 do 5 kdy 1 p콏edstavuje souhlas a 5 nesouhlas} Pro na코e 칰캜ely je pot콏eba n캩co jednoduch칠ho a srozumiteln칠ho, p콏im캩콏en캩 rychl칠ho. Tedy nejl칠pe z toho vypl칳v치 JSON. XML je pro na코e 칰캜ely moc komplexn칤 a v캩t코inu vlastnost칤 nevyu쬴jeme. Bin치rn칤 form치t je sice rychl칳 ale 코patn캩 se odhaluj칤 chyby a je zde hor코칤 univers치lnost serializeru a deserializeru mezi jazyky.


\endinput