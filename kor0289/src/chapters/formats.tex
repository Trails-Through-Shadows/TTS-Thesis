\chapter{Form치ty vyu쮂셨aj칤c칤 se v API}
V t칠to kapitole budou pops치ny p콏edev코칤m dva z치kladn칤 form치ty dat kter칠 jsou st치le aktivn칤. A to JSON a XML.

\section{JSON}
JavaSctript Object Notation neboli JSON je form치t kter칳 je odvozen z Javascriptu. Nicm칠n캩 mnoho dne코n칤ch jazyk콢 u m치 zabudovanou serializaci do JSONU. Jedn치 se o textov칳 form치t z치pisu objekt콢 kter칳 je dob콏e 캜iteln칳 캜lov캩kem. Bohu쬰l nem치 podporu koment치콏콢 oproti XML kter칠 tuto podporu m치. Ukl치d치 data do p치r콢 \textbf{key:value} kdy value m콢쬰 b칳t i dal코칤 objekt nebo pole. Znaky v JSONu mus칤 b칳t v k칩dov치n칤 UTF-8 ale podporuje i speci치ln칤 znaky pokud jsou tzv. escaped. Nap콏칤klad \verb |\uD83D\uDE10| \textit{neutral-face} . Je vyu쮂셨치n prim치rn캩 k v칳m캩n캩 dat mezi webov칳mi aplikacemi a  servery. M치 jednoduch치 ale zato striktn칤 pravidla a tud칤 je jednoduch칠 zkontrolovat jeho spr치vnost. \textbf{odkaz n캩kde na iso normu https://www.iso.org/standard/71616.html} %TODO bibtech na iso normu plus d치t emoji 游땛 t콏eba xetex ale to se pak cel칠 rozbije


\subsection{Pravidla}
\textbf{Key} je v쬯ycky string a reprezentuje atribut. \textbf{Value} je hodnota kterou nab칳v치 key a m콢쬰 b칳t text, 캜칤slo, logick치 hodnota, null, dal코칤 objekt 캜i pole. Jednotliv칠 atributy jsou v쬯y odd캩leny 캜치rkou. Jako p콏칤klad m치me JSON objekt z na코eho API. Tento objekt popisuje hr치캜e, jeho vlastnosti a nav칤c jeho rasu.

\newpage

\begin{listing}
  \begin{minted}{json}
{
  "id": 4,
  "clazz": null,
  "race": {
    "id": 4,
    "title": "Elf",
    "effects": [
      {
        "key": {
          "idRace": 4,
          "idEffect": 25
        },
        "levelReq": 1
      },
      {
        "key": {
          "idRace": 4,
          "idEffect": 28
        },
        "levelReq": 1
      }
    ]
  },
  "title": "Legolas",
  "playerName": "Jo쬶o",
  "inventory": ["dagger","robe"],
  "url": "https://api.tts-game.fun/images/characters/elf-bard.png",
  "health": 8,
  "dead": false
}
  \end{minted}
  \caption{P콏칤klad JSON souboru}
  \label{code:sumaradyasm}
\end{listing}

V tomto JSONu m치me v코echno s 캜칤m se m콢쬰me potkat. Jako prvn칤 m치me \verb|"ID":4|. ID je kl칤캜 a 4 je 캜칤slo. To zna캜칤 쬰 tento objekt m치 sv콢j unik치tn칤 identifik치tor 4. M콢쬰 se ov코em st치t 쬰 by na코e 캜칤slo 4 bylo v uvozovk치ch \verb|"4"|. To by pak bylo ohodnoceno jako text ne jako 캜칤slo a kdybychom s t칤m d치le cht캩li pracovat jako s 캜칤slem tak si ho mus칤me v programu p콏etypovat. \textbf{idk jestli to tu tento p콏칤klad d치vat } S t칤m se tak칠 poj칤 deserializace kdy chceme p콏ev치d캩t JSON zp치tky na objekt tak datov칠 typy v objektu mus칤 sed캩t s t캩mi co jsou v JSONu.

D치le zde m치me na 6 콏치dku \verb|"title":"Elf"|. Value je v tomto p콏칤pad캩 text. Takt칠 tento 콏치dek v kontextu objektu n치m zna캜칤 쬰 je to rasa kter치 m치 n치zev Elf.

O dva 콏치dky v칳코e je \verb|"race":{<vlastnosti>}|. To je p콏칤klad objektu. v tomto p콏칤pad캩 rasy a ta m치 n캩jak칠 sv칠 vlastnosti.

V key \texttt{"effects"} se nach치z칤 pole objekt콢. V tomto p콏칤pad캩 to jsou kl칤캜e co ur캜uj칤 rasu a jej칤 efekt plus od jak칠 칰rovn캩 je tento efekt zp콏칤stupn캩n. Stejn캩 tak na 콏치dku 26 je jako value pole textov칳ch 콏et캩zc콢. V tomto p콏칤pad캩 se jedn치 o invent치콏 hr치캜e a jeho p콏edm캩ty.

A v neposledn칤 콏ad캩 m치me na 콏치dku 3 jako value \texttt{null}. To n치m zna캜칤 쬰 tento konkr칠tn칤 key u tohoto objektu zat칤m nic neobsahuje. M콢쬰 se st치t 쬰 v budoucnu n캩jakou value dostane nebo m콢쬰 existovat u jin칠ho objektu.

A nakonec zde m치me na 콏치dku 29 jako value \texttt{false}. To zna캜칤 logickou hodnotu a tato value m치 datov칳 typ boolean. V na코em p콏칤pad캩 se jedn치 o vlastnost kter치 n치m 콏칤k치 zda je hr치캜 mrtv칳 (\texttt{false}) 캜i nikoli (\texttt{true}).


\section{XML}
Extensible Markup Language je jazyk prim치rn캩 ur캜en칳 na serializaci a p콏en치코en칤 dat. Stejn캩 jako JSON je 캜iteln칳 i 캜lov캩kem. Z치kladn칤 stavebn칤 blok je node. Atributy pak ukl치d치 do p치r콢 kter칳m 콏칤k치me tagy. Za pomoc칤 sv칠 deklarace podporuje ur캜en칤 k칩dov치n칤 a r콢zn칠 verze. Tak칠 za pomoc칤 XML Schema definition podporuje celou 콏adu datov칳ch typ콢. Oproti JSONu je zde podpora koment치콏콢. Standardy spravuje W3C \textbf{fest fajny odkaz na w3c specifikaci do bibtex} %TODO bibtech na w3c


\subsection{Pravidla}
Na za캜치tku dokumentu je v쬯ycky XML deklarace, kter치 ur캜uje o jakou verzi se jedn치 a jak칠 maj칤 znaky k칩dov치n칤.
Tag je p치rov치 zna캜ka. Zapisuje se jako po캜치te캜n칤 tag (<character>) a ukon캜ovac칤 (</character>) kde \textit{character} je n치zev atributu podob캩 jako u JSONu \textbf{key}. Hodnota atributu se p칤코e pr치v캩 mezi po캜치te캜n칤 a ukon캜ovac칤 tag. Takt칠 se m콢쬰 ps치t p콏칤mo do tagu <character id=4>. Tomuto p치ru tag콢 콏칤k치me \textbf{element}. Tzv. \textit{procesory} analyzuj칤 XML dokumenty a pos칤laj칤 d치le strukturovan치 data aplikaci. Procesory m콢쬺u b칳t jak validuj칤c칤 tak nevaliduj칤c칤. Pokud jde o validuj칤c칤 procesor, mus칤 chybu nahl치sit ale po콏치d m콢쬰 pokra캜ovat.


\begin{listing}
  \begin{minted}{xml}
<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="health" type="xs:integer"/>
  <xs:element name="key">
    <xs:complexType>
      <xs:attribute name="idRace" type="xs:integer" />
      <xs:attribute name="idEffect" type="xs:integer" />
    </xs:complexType>
  </xs:element>
  <!-- other schema definitions here -->
</xs:schema>
<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="health" type="xs:integer"/>
  <xs:element name="key">
    <xs:complexType>
      <xs:attribute name="idRace" type="xs:integer" />
      <xs:attribute name="idEffect" type="xs:integer" />
    </xs:complexType>
  </xs:element>
  <!-- other schema definitions here -->
</xs:schema>
<character> 
    <id>4</id>
    <clazz></clazz>
    <race>
        <id>4</id>
        <title>Elf</title>
        <effects>
            <key>
                <idRace>4</idRace>
                <idEffect>25</idEffect>
            </key>
            <levelReq>1</levelReq>
        </effects>
        <effects>
            <key idRace="4" idEffect="28"></key>
            <levelReq>1</levelReq>
        </effects>
    </race>
    <title>Legolas</title>
    <playerName>Jo쬶o</playerName>
    <inventory>dagger</inventory>
    <inventory>robe</inventory>
    <url>https://api.tts-game.fun/images/characters/elf-bard.png</url>
    <health>8</health>
    <dead>false</dead>
</character>
  \end{minted}
  \caption{P콏칤klad XML dokumentu i se sch칠matem}
  %\label{code:sumaradyasm}
\end{listing}

%TODO n캩jak칳 odkaz p캩kn칳 nebo tak n캩co na 
Tento XML dokument reprezentuje stejnou strukturu jako JSON zm칤n캩n칳 v칳코e. Je zde nav칤c na prvn칤 pohled sch칠ma ve kter칠m m콢쬰me ur캜it jeden z mnoha \ref{fig:xml_datatypes} datov칳ch typ콢 pro ka쬯칳 element (콏치dek 3) 캜i atribut (콏치dek 6 a 7). Kdy nen칤 specifikov치no sch칠ma tak v코echny datov칠 typy jsou pouze text. Taky velk치 zm캩na oproti JSONu je 쬰 v칤me o jak칳 objekt se jedn치 (콏치dek 23 a 48). M칤sto oby캜ejn칳ch slo쬰n칳ch z치vorek zde m치me element kter칳 se jmenuje character. P콏edt칤m jsme tuto informaci v JSONu nedostali.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{figures/type-hierarchy.png}
  \caption{Hierarchie datov칳ch typ콢 v XML schema}%\cite{british_museum_2021}}
  \label{fig:xml_datatypes}
\end{figure}
%odkaz na obr치zek v코ech mo쬹칳ch datov칳ch typ콢 https://www.w3.org/TR/xmlschema-2/type-hierarchy.gif a p콏칤mo ta str치nka https://www.w3.org/TR/xmlschema-2/#built-in-datatypes


\endinput