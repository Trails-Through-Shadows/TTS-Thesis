\chapter{Standardy využívané pro tvorbu API}[!ht]
V této kapitole si porovnáme a představíme různé architektury, které se používají pro tvorbu \gls{api}.
Hlavní často využívané nástroje, které si představíme, jsou REST, GraphQL a SOAP.

\subsection*{Úvod}
\gls{api} je univerzální komunikační rozhraní mezi aplikacemi, které můžeme použít pro více druhů koncových aplikací. Ve své podstatě se jedná o soubor definicí, protokolů a občas i nepsaných pravidel.


\section{REST}
\gls{rest}, což můžeme volně přeložit jako reprezentační stavový přenos, je nejčastěji používaná architektura API. Původně byl vytvořen jako vodítko, jak modelovat komunikaci po Internetu, jeho popularita však dále rostla z důvodu jednoduchosti implementace, flexibility z pohledu provádění změn, výkonnosti a přehlednosti i ve velkých projektech.

Webové služby, které pro své API využívají architekturu REST, jsou nazývány RESTful webové služby. Pojem RESTful API většinou označují RESTful web API. Nicméně tyto dva pojmy se mohou zaměňovat nezávisle na sobě.


\subsection{Principy RESTful API}

Níže jsou popsány základní principy, které RESTful API dodržují.

\subsubsection*{Uniform interface}
Jedná se o klíčovou vlastnost RESTful služeb, která indikuje, že server předává a přijímá data v určitém specificky strukturovaném formátu. Nejčastěji se jedná o JSON nebo XML, ale může to být i jiný formát.

Jednotné rozhraní by mělo dodržovat následující pravidla.\
\begin{enumerate}
    \item Požadavky by měly identifikovat zdroje.
    \item Klient je schopen z přijatých dat provést úpravu nebo smazání dat.
    \item Klient je schopen přijmout metadata o tom, o jaký typ zprávy jde a podle toho zjistit, jak tuto zprávu zpracovat.
    \item Klient může dostat informace o ostatních datech, která se vážou k původnímu požadavku. (HATEOAS)
\end{enumerate}

\subsubsection*{Stateless}
Bezstavová komunikační metoda je taková metoda, kdy server obslouží každého klienta zvlášť a nezávisle na jeho předchozích akcích. Klienti mohou dávat požadavky nezávisle na pořadí, server si tedy neuchovává data o klientech.

\subsubsection*{Layered system}
U tohoto stylu architektury se klient může připojit i k jiným zprostředkovatelům a pořád dostane odpověď od serveru. Servery se taktéž mohou dotazovat na jiné servery při zpracovávání požadavků od klienta, tímto způsobem tedy můžeme mít systém rozdělen do více vrstev, jako je bezpečnostní vrstva, aplikační vrstva či business logika, přičemž tyto vrstvy zůstávají pro klienta skryté.

\subsubsection*{Cacheability}
Velká výhoda RESTful webové služeb je to, že podporují cache. V tomto případě server označuje data jako cacheable či non-cacheable, přičemž při stejném dotazu klienta vícekrát za určitý čas se pro cachable data použijí již stáhnutá data. Dobrým příkladem využití je u obrázků, kde je server nemusí pokaždé načítat znovu a tím docílí rychlejší odezvy.

\subsubsection*{Code on demand}
Posledním ze standardů je možnost, že server může vrátit kód, který má klient vykonat, pomocí čehož může server rozšířit klienta o funkcionalitu, například při validaci formuláře se uživateli může ihned zobrazit chybová hláška. Dnes se však tento standard až tak často nevyužívá.


\subsection{Komunikace přes RESTful API} % TODO reformat this bcs its not the same as rest
RESTful API funguje na protokolu HTTP/S. Klient nejprve pošle serveru request strukturovaný podle dokumentace konkrétní API. Server u požadavku zkontroluje, zda je klient oprávněn tuto operaci provést, a následně ho zpracuje odpovídajícím způsobem a klientovi vrátí odpověď s příslušným stavovým kódem.

\subsubsection*{Message body}
Ať už jde o požadavek či odpověď, pokud je třeba přenášet větší množství dat, většinou jsou vložena do message body. Jedná se o čistě textovou reprezentaci dat, jejíž formát není nikde specifikován a je na programátorech samotných, jaký si zvolí. Nicméně nejčastěji se používá výše zmíněný JSON nebo XML.

Například při požadavku GET pro uživatele s ID 1 server vrátí v message body JSON
\begin{verbatim}
	{"name": "Jožko Mrkvička", "age": 30}
\end{verbatim}
Tento objekt reprezentuje uživatele, který se jmenuje Jožko Mrkvička a je mu 30 let.

\subsubsection*{Headers}
V hlavičce požadavku a odpovědi se nachází dodatečné informace. Může se jednat o kódování body, datum a čas, typ obsahu v body, nebo autorizaci na straně klienta jako třeba session key.


\subsection{Požadavky}
Požadavky na RESTful API musí obsahovat následující.

\subsubsection*{URI}
Unique resource identifier je unikátní identifikátor pro určitá data. V kontextu RESTful API se nejčastěji jedná o URL, kterému se taktéž říká endpoint -- specifikace cesty k daným datům.

\subsubsection*{Metoda}
Jak již bylo zmíněno výše, RESTful API typicky používá HTTP/S protokol, z něhož také přebírá metody pro komunikaci, které jsou zde ve zkratce rozepsány.

\begin{description}
    \item[GET] -- Požadavek pro získání dat na základě parametrů v URL. Opakované volání vrátí vždy stejný výsledek.
    \item[POST] -- Požadavek pro vložení kompletně nových dat, přenášených v message body. S opakovaným voláním se zde opět vloží zase ta stejná data.
    \item[PUT] -- Požadavek pro úpravu dat, opět vložených do message body. Opakované volání vrátí vždy stejný výsledek.
    \item[DELETE] -- Požadavek pro smazání dat.
    \item[PATCH] -- Požadavek pro částečnou úpravu dat. Není třeba posílat celý objekt, ale pouze změny.
\end{description}


\subsection{Odpovědi}
REST principy vyžadují, aby v odpovědi byly obsaženy následující prvky.

\subsubsection*{Stavové kódy}
Stavové kódy slouží k rychlé identifikaci toho, daný požadavek dopadl, zda-li bylo vyhodnocení úspěšné nebo se vyskytla chyba. Jejich struktura je pevně daná a její správné použití je základem dobře a efektivně vedené komunikace. Stav je trojmístné číslo, kde je podle počátečního zaznamenán typ odpovědi a následující dvě cifry už slouží k identifikaci jednotlivých stavů v dané kategorii. Kód začínající 2xx značí úspěch, 4xx chybu na straně klienta, 5xx chybu na straně serveru a v neposlední řadě 3xx označuje přesměrování URL.

Nejčastěji využívané kódy jsou tyto:

\begin{description}
    \item[200 OK] -- Vše proběhlo v pořádku.
    \item[201 Created] -- Vše proběhlo v pořádku při požadavku POST (data byla zapsána).
    \item[400 Bad Request] -- Server nepřijímá tato data, chyba je na straně uživatele.
    \item[401 Unauthorized] -- Klient nemá potřebná oprávnění pro vykonání této akce.
    \item[404 Not Found] -- Adresa či data, na které se klient dotazuje, neexistují.
    \item[500 Internal Server Error] -- Obecná chyba na straně serveru.
\end{description}


\subsection{Shrnutí}
REST je dnes obecně nejpoužívanější architektura pro API. Je velice flexibilní, jednoduchá a programátor si může sám určit, který formát pro přenos dat bude používat. Je také velice intuitivní a samopopisný, takže je jeho učící křivka rychlá. Nicméně kvůli textové podobě přenosu dat může být pomalejší než architektury používající binární soubory, což je však možné optimalizovat pomocí cache.


\section{SOAP}
SOAP neboli Simple Object Access Protocol je další z mnoha architektur API. Taktéž využívá primárně aplikační vrstvu HTTP/S, ale je možné ho použít i nad jinými protokoly. Je postaven na XML formátu.


\subsection{Charakteristika}
SOAP je založen na třech základních stavebních kamenech, které definují strukturu přenášených zpráv.

\begin{description}
    \item[Envelope] Zapouzdřuje celou zprávu, určuje jakou strukturu má zpráva mít a jak ji zpracovat.
    \item[Header] Obsahuje informace o zprávě jako jsou například autentizační údaje.
    \item[Body] Samotná data, obsahují informace, které se mají přenést, ať už se jedná o dotaz nebo odpověď.
    \item[(Fault message)] Nepovinná část, která obsahuje kód chyby, actor, string a detail.
\end{description}

Z pohledu klienta je SOAP velmi podobný RESTful architektuře. Klient vygeneruje požadavek ve formátu XML a ten pošle na SOAP server, čímž vyvolá požadovanou aplikaci běžící na něm. Odpověď serveru s požadovanými daty, parametry a hodnotami přepošle nejdříve SOAP request handleru, odkud je následně předána klientovi.

\subsection{Výhody}
\begin{description}
    \item[Nezávislost na platformě] SOAP může běžet na jakémkoli operačním systému či síťovém protokolu, což umožňuje komunikaci mezi různými jazyky jak na Windows tak i Linuxu.
    \item[HTTP protokol] Primárně se používá HTTP protokol, což přináší výhodu, neboť zde není třeba upravovat firewall, ale funguje na jakémkoli protokolu, kde je však nutné komunikační infrastrukturu upravit.
    \item[Zabezpečení] SOAP má vlastní rozšíření Web Services Security, které podporuje bezpečnostní funkce jako x.509 certifikáty, vývojáři definované tokeny, Kerberos tickety a prověření uživatele pomocí ID a hesla. Jak již bylo zmíněno, i samotná podpora HTTP protokolu přidává vrstvu šifrování.
\end{description}

\subsection{Nevýhody}
\begin{description}
    \item[Rychlost] Kvůli vysokému zabudovanému zabezpečení a serializaci do XML je tento protokol velice pomalý v porovnání s ostatními.
    \item[Složitost] Vzhledem k podpoře více protokolů je nemožné plně využít funkcí jednotlivých protokolů jak je tomu u RESTful, například cachování nebo Uniform interface.
\end{description}


\subsection{Shrnutí}
Vzhledem k masivnosti a rychlosti tohoto protokolu se od něj upouští, aby se optimalizovala rychlost tvořených API. To však neznamená, že se už nepoužívá -- díky jeho bezpečnosti je stále využíván bankami, v E-komerci, zdravotnictví a všude, kde je primární apel na bezpečnost.


\section{GraphQL}
GraphQL byl vyvinut Facebookem, dnes již známým pod názvem Meta. Jedná se o open-source query language a runtime určený pro API, který poskytuje deklarativní získávání dat, u kterého si klient přesně určí jaká data potřebuje. Je tedy velice šetrný k datům a snižuje nutnost mít více endpointů pro různě rozdělená či vyplněná data. Díky tomu, že GraphQL může načítat data z různých zdrojů, také není závislý na konkrétní databázi či úložišti.


\subsection{Design}
GraphQL je postaven kolem modelu \textit{dostanu přesně to o co si řeknu} bez nadměrného nebo nedostatečného načítání, což celkově zrychluje přenos dat. Pro definici prostředků využívá typový systém nazvaným schéma, proti kterému je zkontrolována query každého požadavku a až poté je vykonána. Server potom vrátí data ve stejném formátu jako zadaná query, typicky se používá JSON.

\begin{listing}[ht!]
    \inputminted[]{ts}{resources/code/standards/playertype.gql}
    \caption{Příklad schématu v GraphQL}
    \label{code:gql_type}
\end{listing}

\begin{listing}[ht!]
    \inputminted[]{graphql}{resources/code//standards/playerquery.gql}
    \caption{Příklad query v GraphQL}
    \label{code:gql_querry}
\end{listing}


\subsection{Datové typy}
je jich dost a je tu toho dost co popisovat
%TODO
uvidíme jak dlouhé tohle celkově bude


\begin{listing}[ht]
    \inputminted[]{graphql}{resources/code/standards/types.example.gql}
    \caption{Příklady datových typů}
    \label{code:gql_datatypes}
\end{listing}

\begin{description}
    \item[Type system] - Základ typového systému je Query, která určuje, jaké objekty mohou být získány (Výpis \ref{code:gql_type}, řádek 29). Vlastnosti ve výchozím stavu mohou nabývat hodnotu \texttt{null}. Z datový typ se může dát vykřičník abychom označili že tato hodnota nikdy nebude \texttt{null}. \textbf{//todo dále datové typy zde}
    \item[Queries] - Query přesně definuje, jaká data klient potřebuje. Za pomocí Výpisu \ref{code:gql_querry} dostaneme téměř stejný výsledek jako ve Výpisu \ref{code:json_player}, jen celý JSON s odpovědí bude zabalený do objektu \texttt{"characters": {}}
    \item[Mutations] - GraphQL povoluje pozměnění, smazání nebo přidání dat ze strany klienta, přičemž po změně vrací upravená data. Taktéž je zde třeba definovat, jaký tvar budou vrácená data mít. (Výpis \ref{code:gql_datatypes}, řádek //todo)
    \item[Subscriptions] - Podpora je také poskytnuta posílání aktualizací v reálném čase, kde je dotaz velice podobný query. (Výpis \ref{code:gql_datatypes}, řádek 17)
\end{description}


\section{Shrnutí}
Porovnání bylo opět sestaveno na základě vlastních úsudků v nejlepším zájmu pro účely a ideální styl implementace API pro modelovou hru. Co se týče vytížení, tak zde nepředpokládáme velkou zátěž v míře dotazů. Je žádoucí, aby komunikace byla jednoduchá a lehce pochopitelná. Zabezpečení není prioritou, jelikož zde nebudou uloženy žádné citlivé údaje a bez fyzické hry bude API prakticky nevyužitelné. Taktéž není třeba nijak složitě filtrovat přijímaná data, jelikož ve většině případů potřebujeme celé objekty a potenciál pro velkou variaci struktury přijímaných objektů je nízký.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        Rychlost & Jednoduchost & Variabilita & Bezpečnost & Popularita \\
        \hline
        REST     & 1            & 3           & 2          & 1          \\
        SOAP     & 4            & 1           & 1          & 4          \\
        GraphQL  & 2            & 2           & 2          & 2          \\
        \hline
    \end{tabular}
    \caption{Porovnání REST API, SOAP a GrapQL}
    \label{tab:comparison_standards}
\end{table}

Tabulka \ref{tab:comparison_standards} srovnává výše zmíněné architektury pro tvorbu API. Bodování je vytvořeno se stejnými pravidly, jako tomu bylo v Tabulce \ref{tab:formats_comparison}. Pro účely modelové hry nejlépe odpovídá REST díky jeho jednoduchosti a rozšířenosti. Je rychlý a spolehlivý, využívá se především pro veřejná API s aplikacemi řízených zdroji. SOAP je určen pro velké firmy, kde je prioritizovaná bezpečnost jako a taktéž má příkrou učící křivku. GraphQL je určen především pro komplexní systémy vyžadující flexibilní data. Proto bude v rámci práce implementována komunikace přes RESTful API.

\endinput