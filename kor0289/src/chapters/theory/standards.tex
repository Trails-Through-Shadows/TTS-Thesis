\chapter{Standardy využívané pro tvorbu API}\label{chap:standards}
V této kapitole si porovnáme a představíme různé architektury, které se používají pro tvorbu \gls{api}.
Hlavní často využívané nástroje, které si představíme, jsou \gls{rest}, GraphQL a SOAP.

\subsection*{Úvod}
\gls{api} je univerzální komunikační rozhraní mezi aplikacemi, které můžeme použít pro více druhů koncových aplikací. Ve své podstatě se jedná o soubor definicí, protokolů a občas i nepsaných pravidel.


\section{REST}\label{sec:rest}
\gls{rest}, což můžeme volně přeložit jako reprezentační stavový přenos, je nejčastěji používaná architektura API. Původně byl vytvořen jako vodítko, jak modelovat komunikaci po Internetu, jeho popularita však dále rostla z důvodu jednoduchosti implementace, flexibility z pohledu provádění změn, výkonnosti a přehlednosti i ve velkých projektech.

Webové služby, které pro své API využívají architekturu REST, jsou nazývány RESTful webové služby. Pojem RESTful API většinou označují RESTful web API. Nicméně tyto dva pojmy se mohou zaměňovat nezávisle na sobě. \cite[]{devToApiStyles}


\subsection{Principy RESTful API}\label{sec:rest:principles}

Níže jsou popsány základní principy, které RESTful API dodržují.\cite{restfulApi}\cite[]{phd:restful_api}

\subsubsection*{Uniform interface}
Jedná se o klíčovou vlastnost RESTful služeb, která indikuje, že server předává a přijímá data v určitém specificky strukturovaném formátu. Nejčastěji se jedná o JSON nebo XML, ale může to být i jiný formát.

Jednotné rozhraní by mělo dodržovat následující pravidla.\
\begin{itemize}
    \item Požadavky by měly identifikovat zdroje.
    \item Klient je schopen z přijatých dat provést úpravu nebo smazání dat.
    \item Klient je schopen přijmout metadata o tom, o jaký typ zprávy jde a podle toho zjistit, jak tuto zprávu zpracovat.
    \item Klient může dostat informace o ostatních datech, která se vážou k původnímu požadavku. (\gls{hateoas})
\end{itemize}

\subsubsection*{Stateless}
Bezstavová komunikační metoda je taková metoda, kdy server obslouží každého klienta zvlášť a nezávisle na jeho předchozích akcích. Klienti mohou dávat požadavky nezávisle na pořadí, server si tedy neuchovává data o klientech.

\subsubsection*{Layered system}
U tohoto stylu architektury se klient může připojit i k jiným zprostředkovatelům a pořád dostane odpověď od serveru. Servery se taktéž mohou dotazovat na jiné servery při zpracovávání požadavků od klienta, tímto způsobem tedy můžeme mít systém rozdělen do více vrstev, jako je bezpečnostní vrstva, aplikační vrstva či business logika, přičemž tyto vrstvy zůstávají pro klienta skryté.

\subsubsection*{Cacheability}
Velká výhoda RESTful webových služeb je ta, že podporují cache. V tomto případě server označuje data jako cacheable či non-cacheable, přičemž při stejném dotazu klienta vícekrát za určitý čas se pro cachable data použijí již stáhnutá data. Dobrým příkladem využití je u obrázků, kde je server nemusí pokaždé načítat znovu a tím docílí rychlejší odezvy.

\subsubsection*{Code on demand}
Posledním ze standardů je možnost, že server může vrátit kód, který má klient vykonat, pomocí čehož může server rozšířit klienta o funkcionalitu, například při validaci formuláře se uživateli může ihned zobrazit chybová hláška. Dnes se však tento standard až tak často nevyužívá.


\subsection{Komunikace přes RESTful API} % TODO reformat this bcs its not the same as rest
RESTful API funguje na protokolu HTTP/S. Klient nejprve pošle serveru request strukturovaný podle dokumentace konkrétní API. Server u požadavku zkontroluje, zda je klient oprávněn tuto operaci provést, a následně ho zpracuje odpovídajícím způsobem a klientovi vrátí odpověď s příslušným stavovým kódem.

\subsubsection*{Message body}
Ať už jde o požadavek či odpověď, pokud je třeba přenášet větší množství dat, většinou jsou vložena do message body. Jedná se o čistě textovou reprezentaci dat, jejíž formát není nikde specifikován a je na programátorech samotných, jaký si zvolí. Nicméně nejčastěji se používá výše zmíněný JSON nebo XML.

Například při požadavku GET pro uživatele s ID 1 server vrátí v message body JSON
\begin{verbatim}
	{"name": "Jožko Mrkvička", "age": 30}
\end{verbatim}
Tento objekt reprezentuje uživatele, který se jmenuje Jožko Mrkvička a je mu 30 let.

\subsubsection*{Headers}
V hlavičce požadavku a odpovědi se nachází dodatečné informace. Může se jednat o kódování body, datum a čas, typ obsahu v body, nebo autorizaci na straně klienta jako třeba session key.


\subsection{Požadavky}
Požadavky na RESTful API musí obsahovat následující.

\subsubsection*{URI}
Unique resource identifier je unikátní identifikátor pro určitá data. V kontextu RESTful API se nejčastěji jedná o URL, kterému se taktéž říká endpoint -- specifikace cesty k daným datům.

\subsubsection*{Metoda}
Jak již bylo zmíněno výše, RESTful API typicky používá HTTP/S protokol, z něhož také přebírá metody pro komunikaci, které jsou zde ve zkratce rozepsány.

\begin{itemize}
    \item GET -- Požadavek pro získání dat na základě parametrů v URL. Opakované volání vrátí vždy stejný výsledek.
    \item POST -- Požadavek pro vložení kompletně nových dat, přenášených v message body. Opakované volání této metody vrátí pokaždé jiný výsledek.
    \item PUT -- Požadavek pro úpravu dat, opět vložených do message body. Opakované volání vrátí vždy stejný výsledek.
    \item DELETE -- Požadavek pro smazání dat.
    \item PATCH -- Požadavek pro částečnou úpravu dat. Není třeba posílat celý objekt, ale pouze změny.
\end{itemize}


\subsection{Odpovědi}
REST principy vyžadují, aby v odpovědi byly obsaženy následující prvky.

\subsubsection*{Stavové kódy}
Stavové kódy slouží k rychlé identifikaci toho, daný požadavek dopadl, zda-li bylo vyhodnocení úspěšné nebo se vyskytla chyba. Jejich struktura je pevně daná a její správné použití je základem dobře a efektivně vedené komunikace. Stav je trojmístné číslo, kde je podle počátečního zaznamenán typ odpovědi a následující dvě cifry už slouží k identifikaci jednotlivých stavů v dané kategorii. Kód začínající 2xx značí úspěch, 4xx chybu na straně klienta, 5xx chybu na straně serveru a v neposlední řadě 3xx označuje přesměrování URL.

Nejčastěji využívané kódy jsou tyto:

\begin{itemize}
    \item 200 OK -- Vše proběhlo v pořádku.
    \item 201 Created -- Vše proběhlo v pořádku při požadavku POST (data byla zapsána).
    \item 400 Bad Request -- Server nepřijímá tato data, chyba je na straně uživatele.
    \item 401 Unauthorized -- Klient nemá potřebná oprávnění pro vykonání této akce.
    \item 404 Not Found -- Adresa či data, na které se klient dotazuje, neexistují.
    \item 500 Internal Server Error -- Obecná chyba na straně serveru.
\end{itemize}


\subsection{Shrnutí}
REST je dnes obecně nejpoužívanější architektura pro API. Je velice flexibilní, jednoduchá a programátor si může sám určit, který formát pro přenos dat bude používat. Je také velice intuitivní a samopopisný, takže není náročný na naučení. Nicméně kvůli textové podobě přenosu dat může být pomalejší než architektury používající binární soubory, což je však možné optimalizovat pomocí cache. \cite[]{devToApiStyles}


\section{SOAP}
SOAP neboli Simple Object Access Protocol je další z mnoha architektur API. Taktéž využívá primárně aplikační vrstvu HTTP/S, ale je možné ho použít i nad jinými protokoly. Je postaven na XML formátu.


\subsection{Charakteristika}
SOAP je založen na třech základních stavebních kamenech, které definují strukturu přenášených zpráv.

\begin{itemize}
    \item Envelope -- Zapouzdřuje celou zprávu, určuje jakou strukturu má zpráva mít a jak ji zpracovat.
    \item Header -- Obsahuje informace o zprávě jako jsou například autentizační údaje.
    \item Body -- Samotná data, obsahují informace, které se mají přenést, ať už se jedná o dotaz nebo odpověď.
    \item (Fault message) -- Nepovinná část, která obsahuje kód chyby, aktéra, textový řetězec a detail.
\end{itemize}

Z pohledu klienta je SOAP velmi podobný RESTful architektuře. Klient vygeneruje požadavek ve formátu XML a ten pošle na SOAP server, čímž vyvolá požadovanou aplikaci běžící na něm. Odpověď serveru s požadovanými daty, parametry a hodnotami přepošle nejdříve SOAP request handleru, odkud je následně předána klientovi.

\subsection{Výhody}

SOAP je \textbf{nezávislý na platformě}. Neboli může běžet na jakémkoli operačním systému či síťovém protokolu, což umožňuje komunikaci mezi různými jazyky jak na Windows tak i Linuxu.

Primárně se používá \textbf{HTTP protokol}, což přináší výhodu, neboť zde není třeba upravovat firewall, ale funguje na jakémkoli protokolu, kde je však nutné komunikační infrastrukturu upravit.

Soap je velice \textbf{zabezpečený} -- má vlastní rozšíření Web Services Security, které podporuje bezpečnostní funkce jako x.509 certifikáty, vývojáři definované tokeny, Kerberos tickety a prověření uživatele pomocí ID a hesla. Jak již bylo zmíněno, i samotná podpora HTTP protokolu přidává vrstvu šifrování.

\subsection{Nevýhody}
\begin{itemize}
    \item Rychlost -- Kvůli vysokému zabudovanému zabezpečení a serializaci do XML je tento protokol velice pomalý v porovnání s ostatními.
    \item Složitost -- Vzhledem k podpoře více protokolů je nemožné plně využít funkcí jednotlivých protokolů jak je tomu u RESTful, například cachování nebo Uniform interface.
\end{itemize}


\subsection{Shrnutí}
Vzhledem k masivnosti a rychlosti tohoto protokolu se od něj upouští, aby se optimalizovala rychlost tvořených API. To však neznamená, že se už nepoužívá -- díky jeho bezpečnosti je stále využíván bankami, v E-komerci, zdravotnictví a všude, kde je primární apel na bezpečnost.


\section{GraphQL}
GraphQL byl vyvinut Facebookem, dnes již známým pod názvem Meta. Jedná se o open-source dotazovací jazyk a prostředí pro běh programu určený pro API, který poskytuje deklarativní získávání dat, u kterého si klient přesně určí jaká data potřebuje. Je tedy velice šetrný k datům a snižuje nutnost mít více endpointů pro různě rozdělená či vyplněná data. Díky tomu, že GraphQL může načítat data z různých zdrojů, také není závislý na konkrétní databázi či úložišti.


\subsection{Design}
GraphQL je postaven na principu vrácení pouze těch dat, o které si klient řekne, bez nadměrného nebo nedostatečného načítání, což celkově zrychluje přenos dat. Pro definici prostředků využívá typový systém nazvaným schéma, proti kterému je zkontrolována query každého požadavku a až poté je vykonána. Server potom vrátí data ve stejném formátu jako zadaná query, typicky se používá JSON. Níže jsou popsány nejdůležitější stavební kameny GraphQL.

\begin{listing}[ht!]
    \inputminted[]{ts}{resources/code/standards/playertype.gql}
    \caption{Příklad schématu v GraphQL}
    \label{code:gql_type}
\end{listing}

\begin{listing}[ht!]
    \inputminted[]{graphql}{resources/code//standards/playerquery.gql}
    \caption{Příklad query v GraphQL}
    \label{code:gql_querry}
\end{listing}


\begin{listing}[ht!]
    \inputminted[]{graphql}{resources/code/standards/types.example.gql}
    \caption{Příklady datových typů}
    \label{code:gql_datatypes}
\end{listing}

\begin{itemize}
    \item Type system \sectionref{sec:graphql:datatypes} -- Základ typového systému je Query, která určuje, jaké objekty mohou být získány \coderef{code:gql_type}[, řádek 29]. Vlastnosti ve výchozím stavu mohou nabývat hodnotu \texttt{null}. Za datový typ se může dát vykřičník abychom označili že tato hodnota nikdy nebude \texttt{null}.
    \item Queries \subsectionref{sec:graphql:query} -- Query přesně definuje, jaká data klient potřebuje. Za pomocí Výpisu \ref{code:gql_querry}dostaneme téměř stejný výsledek jako ve Výpisu \ref{code:json_player}, jen celý JSON s odpovědí bude zabalený do objektu \texttt{"characters": {}}.
    \item Mutations \subsectionref{sec:graphql:mutations} -- GraphQL povoluje pozměnění, smazání nebo přidání dat ze strany klienta, přičemž po změně vrací upravená data. Taktéž je zde třeba definovat, jaký tvar budou vrácená data mít. \coderef{code:gql_datatypes}[]
    \item Subscriptions \subsectionref{sec:graphql:mutations} -- Podpora je také poskytnuta posílání aktualizací v reálném čase, kde je dotaz velice podobný query. \coderef{code:gql_datatypes}[, řádek 17].
\end{itemize}

\subsection{Systém datových typů}\label{sec:graphql:datatypes}
GraphQL definuje několik druhů datových typů, které mohou být ve schématu.

\textbf{Scalar type} jsou základní datové typy jako \texttt{Int}, \texttt{Float}, \texttt{String}, \texttt{Boolean} a \texttt{ID}. Tyto datové typy jsou automaticky serializovány a deserializovány do příslušných datových typů programovacího jazyka.
\texttt{Int} -- znaménkové celé třiceti-dvou bitové číslo.
\texttt{Float} -- znaménkové šedesáti-čtyř bitové číslo s plovoucí desetinnou čárkou.
\texttt{String} -- UTF-8 textový řetězec.
\texttt{Boolean} -- logická hodnota \texttt{true} nebo \texttt{false}.
\texttt{ID} -- unikátní identifikátor, který je serializován jako \texttt{String}.

Většina typů které se definují v GraphQL jsou \textbf{Object types} Tyto typy obsahují vlastnosti a každá vlastnost má svůj datový typ. \coderef{code:gql_datatypes}[ řádek 1 až 4] definuje objektový typ \texttt{Key}.

\textbf{Query} je datový typ který můžeme použít pro dotazování se dalších dat ze zdroje dat. Když se dotážeme na \texttt{getAllUsers}, tak dostaneme pole uživatelů. \coderef{code:gql_datatypes}[ řádek 7]. Podobně \textbf{Mutation} můžeme použít pro úpravu dat podle parametrů. \coderef{code:gql_datatypes}[ řádek 31].

\textbf{Input type} je obdobný jako Object type ale s tím rozdílem, že jsou jen pro definování vstupních argumentů pro požadavky a mutace. \coderef{code:gql_datatypes}[ řádek 21 až 27].

\textbf{Enumeration type} by se dal považovat za skalární datový typ, který má pevně dané hodnoty. \coderef{code:gql_datatypes}[ řádek 34 až 38].

Vykřičníkem se označuje, že objekt musí mít pokaždé hodnotu neboli \textbf{Non-Null} \coderef{code:gql_datatypes}[ řádek 41]. Hranatými závorkami můžeme označit pole objektů neboli \textbf{List}. \coderef{code:gql_datatypes}[ řádek 43].

\subsection{Query}\label{sec:graphql:query}
Queries jsou základní přístupové body pro data v GraphQL. Zde si klient urči, jaké data a vlastnosti chce získat. Oproti REST API, kde se většinou a bez filtrování vrací předem určená struktura.

GraphQL server poskytuje prostředí (\textit{GraphQL playground}), kde se klient může podívat na schéma, všechny dostupné datové typy a požadavky které si taktéž může vyzkoušet. To se hodí pro testovací účely když ještě není hotov frontend nebo když si chce klient ověřit zda generované požadavky vrací očekávané výsledky.

Obyčejný požadavek vypadá takto \coderef{code:gql_querry} a jeho odpověď v JSON formátu \coderef{code:gql_query_simple_response}.
Ovšem syntax požadavků není pevně daná. V příkladu požadavku jsou dvě query a jsou ekvivalentní. Syntaxe je závislá na implementaci na straně serveru na základě schématu. Informace jak přesně má vypadat syntaxe nalezneme právě v \textit{GraphQL playground}.

Můžeme samozřejmě mít zanořené požadavky jako jsou v příkladu \coderef{code:gql_querry} na řádku 3 a 4.

\begin{listing}[H]
    \inputminted[]{graphql}{resources/code/standards/query.example.gql}
    \caption{Příklad jednoduché query}
    \label{code:gql_query_simple}
\end{listing}

\begin{listing}[H]
    \inputminted[]{json}{resources/code/standards/query.example.gql.jsonc}
    \caption{Příklad odpovědi pro query \ref{code:gql_query_simple}}
    \label{code:gql_query_simple_response}
\end{listing}

\subsection{Mutations}\label{sec:graphql:mutations}
Mutations jsou přístupové body, které umožnují úpravu dat, neboli právu, vkládání nových dat a mazání dat. Stuktura mutací je stejná jako od požadavků. \coderef{code:gql_datatypes}[, řádek 10] definuje vytvářecí mutaci \texttt{createUser}. U aktualizačního požadavku musíme navíc specifikovat ID objektu který chceme upravovat. A naposledy u mazání dat potřebujeme pouze identifikaci objektu.

Všechny tyto operace by měly vracet právě zmodifikovaný objekt. Tento požadavek není povinný ale pro vývojáře to je velké zjednodušení práce a například nemusí se znovu dotazovat aby se přesvědčili že úprava proběhla úspěšně nebo po vytvoření objektu se nemusí znovu dotazovat aby získali právě vytvořený či upravený objekt.

Taktéž je dobrý návrh aby upravovací operace měli jako vstupní parametr objekt místo jednotlivých vlastností objektu.


\subsection{Subscriptions}\label{sec:graphql:subscriptions}
Do teď probírané požadavky a mutace probíhali formou request-response a poté bylo spojení přerušeno, což není ideální pro komunikaci v reálném čase. Pro aplikace reálném čase potřebujeme použít web socket protokol, který společně s GraphQL subsriptions nám umožní navázat komunikaci jen jednou a poté použít publish-subsribe model, ketrý nám umožnuje zasílat data jen při změně dat bez nutnosti opakovaného dotazování.

Subscription vypadá stejně jako mutace nebo query a platí pro něj stejná pravidla. Je zde pouze jeden rozdíl a to ten, že místo klíčových slov \texttt{mutation} nebo \texttt{query} použijeme klíčové slovo \texttt{subscription}.


\section{Shrnutí}
Porovnání bylo opět sestaveno na základě vlastních úsudků v nejlepším zájmu pro účely a ideální styl implementace API pro modelovou hru. Co se týče vytížení, tak zde nepředpokládáme velkou zátěž v míře dotazů. Je žádoucí, aby komunikace byla jednoduchá a lehce pochopitelná. Zabezpečení není prioritou, jelikož zde nebudou uloženy žádné citlivé údaje a bez fyzické hry bude API prakticky nevyužitelné. Taktéž není třeba nijak složitě filtrovat přijímaná data, jelikož ve většině případů potřebujeme celé objekty a potenciál pro velkou variaci struktury přijímaných objektů je nízký.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        Rychlost & Jednoduchost & Variabilita & Bezpečnost & Popularita \\
        \hline
        REST     & 1            & 3           & 2          & 1          \\
        SOAP     & 4            & 1           & 1          & 4          \\
        GraphQL  & 2            & 2           & 2          & 2          \\
        \hline
    \end{tabular}
    \caption{Porovnání REST API, SOAP a GraphQL}
    \label{tab:comparison_standards}
\end{table}

Tabulka \ref{tab:comparison_standards} srovnává výše zmíněné architektury pro tvorbu API. Bodování je vytvořeno se stejnými pravidly, jako tomu bylo v Tabulce \ref{tab:formats_comparison}. Pro účely modelové hry nejlépe odpovídá REST díky jeho jednoduchosti a rozšířenosti. Je rychlý a spolehlivý, využívá se především pro veřejná API s aplikacemi, které se zaměřují na práci se zdroji. SOAP je určen pro velké firmy, kde je prioritizovaná bezpečnost a taktéž je náročný na naučení. GraphQL je určen především pro systémy vyžadující flexibilní data. Proto bude v rámci práce implementována komunikace přes RESTful API\@.

\endinput