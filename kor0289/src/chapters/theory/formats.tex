\chapter{Formáty využívající se v API}\label{chap:formats}
V této kapitole budou popsány především dva základní formáty dat které jsou stále aktivní -- JSON a XML.


\subsection*{Serializace a deserializace}\label{sec:formats:deserialization} %TODO cite https://www.baeldung.com/cs/serialization-deserialization
Serializace a deserializace jsou důležité koncepty v programování, které umožňují ukládat, přenášet a znovu sestavit data. Používají se celou řadu věcí, od ukládání objektů do databáze přes posílání dat po síti až po pro účely reprezentace mezipaměťi.

Objekt, se kterým se během těchto procesů pracuje, má 3 základní vlastnosti: identitu, stav a chování. Stav reprezentuje samotná data objektu.

\textbf{Serializace} je proces převádění stavu objektů do proudu bytů, který může být kdekoliv poslán nebo uložen a později zase rekonstruován do původního objektu. Pro serializaci je třeba stanovit formát, ve kterém budou data zapsána. Příkladem je právě JSON nebo XML, ovšem používá se i binární reprezentace dat. Tato reprezentace se často využívá pro výkonnostní potřeby, protože je typicky rychlejší na zápis a čtení, nevýhodou však je snížená čitelnost běžným člověkem.

\textbf{Deserializace} je opačný proces, kdy se data z bytového proudu převedou zpět na objekt. Tento proces je důležitý pro získání dat z různých zdrojů, jako jsou soubory, databáze nebo síťové zdroje.

Jednou z nevýhod serializace a deserializace jsou vysoké nároky na výkon, neboť převod může trvat nezanedbatelné množství času, obzvlášť u velkých objektů. Za zmínku stojí i fakt, že ne všechny objekty mohou být serializovány, příkladem mohou být sockety nebo file handlery. \cite[]{serializationDeserialization}


\section{JSON}\label{sec:formats:json}
JavaScript Object Notation neboli JSON je formát, který je odvozen z Javascriptu, nicméně mnoho dnešních jazyků už má serializaci do JSONu zabudovanou interně. Jedná se o textový formát zápisu objektů, který je dobře čitelný člověkem. Ukládá data do párů \textbf{key:value} kdy key je klíč a value hodnota, která je pod ním uložená, obvykle může jít o číslo, textový řetězec, pole nebo i další objekt. Znaky v JSONu musí být v kódování UTF-8, ale formát podporuje i speciální znaky pokud jsou escaped, jako příklad můžeme uvést jakékoliv emotikony. JSON je využíván primárně k výměně dat mezi webovými aplikacemi a servery, ale dá se používat i pro jednoduché databáze. Má prostá ale zato striktní pravidla podle normy ISO \cite[ISO21778]{ISO71616} a tudíž je jednoduché zkontrolovat jeho správnost. Jeden z jeho nedostatků je, že nemá podporu komentářů oproti XML, které tuto podporu má. Ovšem můžeme použít formát JSONC který má podporu komentářů ale bohužel není jeho serializace a především deserializace tak široce podporovaná programovacími jazyky.\cite[]{enwiki:1217773005}\cite[]{zapierDataFormats}
%\textbf{ TODO odkaz někde na iso normu https://www.iso.org/standard/71616.html}


\subsection{Pravidla}\label{sec:formats:json:rules}
\textbf{Key} neboli klíč daného objektu je vždy string a reprezentuje název určitého atributu. \textbf{Value} představuje hodnotu, kterou tento atribut nabývá a může být datového typu text, číslo, logická hodnota, null, další objekt či pole. Jednotlivé atributy jsou vždy odděleny čárkou. Jako příklad je uveden JSON objekt z API modelové hry, který popisuje hráče, jeho vlastnosti a jeho rasu, reprezentovanou jako vnořený objekt.

\begin{listing}[ht!]
    \inputminted{json}{resources/code/standards/player.json}
    \caption{Příklad JSON objektu}
    \label{code:json_player}
\end{listing}

V níže přiloženém JSONu \coderef{code:json_player} můžeme vidět všechno, s čím se u tohoto datového formátu můžeme setkat. Jako první atribut, tento objekt má \verb|"id":4|, kde id je klíč a 4 je číslo -- to značí, že tento objekt má svůj unikátní identifikátor 4.

Níže \coderef{code:json_player}[, řádek 6] můžeme vidět atribut \verb|"title":"Elf"|. Value je v tomto případě text, který poznáme podle zaobalení uvozovek. Tento řádek v kontextu celého objektu značí, že se jedná o rasu postavy, která má název \textit{Elf}.

Atribut, který tento text zaobaluje, je \texttt{"race"}. \coderef{code:json_player}[, řádek 4] Jedná se o příklad objektu, v tomto případě rasy, která má své vlastnosti reprezentované právě tímto objektem.

V atributu \texttt{"effects"} se nachází pole objektů. V tomto případě to jsou objekty obsahující klíč s id rasy a jejím efektem, ke kterému je přidána také informace o tom, od jaké úrovně je tento efekt zpřístupněn. Podobně tak na řádku 26 je jako value klíče \texttt{inventory} pole textových řetězců znázorňující předměty, které hráč vlastní.

Dále si můžeme povšimnout atributu \texttt{clazz} \coderef{code:json_player}[, řádek 3], který má hodnotu \texttt{null}. To nám značí, že tento konkrétní klíč u objektu zatím nic neobsahuje. Může se stát že jen nebyl přiřazen a v budoucnu nějakou hodnotu dostane.

A nakonec zde máme na řádku 29 atribut \texttt{dead} s hodnotou \texttt{false}. Tato hodnota značí logickou hodnotu, která má datový typ boolean. V našem případě se jedná o vlastnost, která nám říká, zda je hráč mrtvý (\texttt{true}) či nikoli (\texttt{false}).


\section{XML}\label{sec:formats:xml}
Extensible Markup Language je jazyk primárně určený na serializaci a přenášení dat, který je podobně jako JSON čitelný i člověkem. Základní stavební blok je node, atributy jsou uloženy do párů kterým říkáme tagy. Za pomocí své deklarace podporuje určení kódování a různé verze. Díky XML Schema definition také podporuje celou řadu datových typů a oproti JSONu podporuje i komentáře. Standardy spravuje společnost W3C. \cite[]{zapierDataFormats} \cite[text]{awsXML} %\textbf{fest fajny odkaz na w3c specifikaci do bibtex} %TODO bibtech na w3c


\subsection{Pravidla}\label{sec:formats:xml:rules}
Na začátku dokumentu je vždycky XML deklarace, která určuje, o jakou verzi se jedná a jaké mají znaky kódování.
Samotná data jsou zaznamenána pomocí párových tagů, dohromady nazývaným \textbf{element}, které se zapisují jako počáteční (\texttt{<character>}) a ukončovací (\texttt{</character>}) tag, kde \textit{character} značí název atributu, podobně jako \textbf{key} u JSONu. Hodnota atributu se píše buď mezi počáteční a ukončovací tag, nebo přímo do tagu samotného (\texttt{<character id=4>}). Tzv. \textit{procesory} analyzují XML dokumenty a posílají dále strukturovaná data aplikaci, která se využívá. Procesory můžou být jak validující tak nevalidující, přičemž validující musí nalezenou chybu nahlásit ale pořád mohou v parsování pokračovat. \cite[]{w3XMLSchema} \cite[]{enwiki:1218715782}

\begin{listing}[ht!]
    \inputminted{xml}{resources/code/standards/player.xml}
    \caption{Příklad XML dokumentu i se schématem}
    \label{code:xml_player}
\end{listing}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/type-hierarchy.png}
    \caption{Hierarchie datových typů v XML schema \cite[]{w3XMLSchemaBuiltIn}}
    \label{fig:xml_datatypes}
\end{figure}


%TODO nějaký odkaz pěkný nebo tak něco na xml asi idk co jsem tím tady chtěl říct
Tento XML dokument \coderef{code:xml_player} reprezentuje stejnou strukturu jako JSON popsaný výše. Oproti němu je však rozšířen o schéma, ve kterém můžeme určit jeden z mnoha datových typů \ref{fig:xml_datatypes} pro každý element \coderef{code:xml_player}[, řádek 3] či atribut \coderef{code:xml_player}[, řádek 6 a 7]. Když není schéma specifikováno, všechny datové typy jsou považovány za text. Velká změna oproti JSONu také spočívá v tom, že víme, o jaký objekt se jedná (řádek 23 a 48) -- místo obyčejných složených závorek zde máme element se jménem \textit{character}, což je informace, kterou JSON neposkytuje.


\section{Shrnutí}
V předchozí části byly popsány dva základní formáty pro serializaci a deserializaci dat -- JSON a XML. Oba formáty mají své výhody a nevýhody, které je třeba zvážit při výběru vhodného formátu pro konkrétní použití.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
               & Čitelnost & Jednoduchost & Rychlost & Skladnost \\
        \hline
        JSON   & 1         & 1            & 2        & 3         \\
        \hline
        XML    & 2         & 3            & 4        & 4         \\
        \hline
        Binary & 5         & 4            & 1        & 1         \\
        \hline
    \end{tabular}
    \caption{Porovnání JSON, XML a Binary }
    \label{tab:formats_comparison}
\end{table}

Tabulka \ref{tab:formats_comparison} srovnává výše zmíněné technologie podle několika kritérií, které jsou důležité pro výběr vhodného formátu pro serializaci a deserializaci dat. \footnote[1]{Známkování jsem prováděl čistě podle vlastního uvážení vzhledem k tomu, co bude pro naše použití nejvhodnější} \footnote[2]{Hodnocení je vedeno jako známka na škále od 1 do 5 kdy 1 představuje souhlas a 5 nesouhlas} Pro naše účely je potřeba, aby byl formát jednoduchý a srozumitelný, ale pořád přiměřeně rychlý. XML je pro naše účely moc komplexní a většinou se používá pro velké a komplexní struktury dat, což není náš případ. Binární formát je sice rychlý, ale špatně se odhalují chyby a také je zdě větší problém s univerzálností serializeru a deserializeru mezi jazyky. JSON je pro nás ideální, neboť je jednoduchý, rychlý a dobře čitelný, proto bude použit pro reprezentaci přenosových dat v naší aplikaci.


\begin{listing}[H]
    \begin{minted}{java}
    @Override
    public List<Instruction> visitExprStat(ProjExprParser.ExprStatContext ctx) {
        log.trace("{}Visiting \texprStat", "    ".repeat(ctx.depth()));
        List<Instruction> instructions = new ArrayList<>(visit(ctx.expr()));
        instructions.add(Instruction.builder().instruction(InstructionType.POP).build());
        return instructions;
    }

    \end{minted}

    \caption{caption}
    \label{code:label}
\end{listing}

\endinput