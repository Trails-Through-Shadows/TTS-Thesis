\chapter{Form치ty vyu쮂셨aj칤c칤 se v API}
V t칠to kapitole budou pops치ny p콏edev코칤m dva z치kladn칤 form치ty dat kter칠 jsou st치le aktivn칤 -- JSON a XML.


\subsection*{Serializace a deserializace} %TODO cite https://www.baeldung.com/cs/serialization-deserialization
Serializace a deserializace jsou d콢le쬴t칠 koncepty v programov치n칤, kter칠 umo쮄갓j칤 ukl치dat, p콏en치코et a znovu sestavit data. Pou쮂셨aj칤 se celou 콏adu v캩c칤, od ukl치d치n칤 objekt콢 do datab치ze p콏es pos칤l치n칤 dat po s칤ti a po pro 칰캜ely reprezentace mezipam캩콘i.

Objekt, se kter칳m se b캩hem t캩chto proces콢 pracuje, m치 3 z치kladn칤 vlastnosti: identitu, stav a chov치n칤. Stav reprezentuje samotn치 data objektu.

\textbf{Serializace} je proces p콏ev치d캩n칤 stavu objekt콢 do proudu byt콢, kter칳 m콢쬰 b칳t kdekoliv posl치n nebo ulo쬰n a pozd캩ji zase rekonstruov치n do p콢vodn칤ho objektu. Pro serializaci je t콏eba stanovit form치t, ve kter칠m budou data zaps치na. P콏칤kladem je pr치v캩 JSON nebo XML, ov코em pou쮂셨치 se i bin치rn칤 reprezentace dat. Tato reprezentace se 캜asto vyu쮂셨치 pro v칳konnostn칤 pot콏eby, proto쬰 je typicky rychlej코칤 na z치pis a 캜ten칤, nev칳hodou v코ak je sn칤쬰n치 캜itelnost b캩쬹칳m 캜lov캩kem.

\textbf{Deserializace} je opa캜n칳 proces, kdy se data z bytov칠ho proudu p콏evedou zp캩t na objekt. Tento proces je d콢le쬴t칳 pro z칤sk치n칤 dat z r콢zn칳ch zdroj콢, jako jsou soubory, datab치ze nebo s칤콘ov칠 zdroje.

Jednou z nev칳hod serializace a deserializace jsou vysok칠 n치roky na v칳kon, nebo콘 p콏evod m콢쬰 trvat nezanedbateln칠 mno쬽tv칤 캜asu, obzvl치코콘 u velk칳ch objekt콢. Za zm칤nku stoj칤 i fakt, 쬰 ne v코echny objekty mohou b칳t serializov치ny, p콏칤kladem mohou b칳t sockety nebo file handlery.


\section{JSON}
JavaScript Object Notation neboli JSON je form치t, kter칳 je odvozen z Javascriptu, nicm칠n캩 mnoho dne코n칤ch jazyk콢 u m치 serializaci do JSONu zabudovanou intern캩. Jedn치 se o textov칳 form치t z치pisu objekt콢, kter칳 je dob콏e 캜iteln칳 캜lov캩kem. Ukl치d치 data do p치r콢 \textbf{key:value} kdy key je kl칤캜 a value hodnota, kter치 je pod n칤m ulo쬰n치, obvykle m콢쬰 j칤t o 캜칤slo, textov칳 콏et캩zec, pole nebo i dal코칤 objekt. Znaky v JSONu mus칤 b칳t v k칩dov치n칤 UTF-8, ale form치t podporuje i speci치ln칤 znaky pokud jsou escaped, jako p콏칤klad m콢쬰me uv칠st znaky \verb |\uD83D\uDE10| nebo \textit{neutral-face}. JSON je vyu쮂셨치n prim치rn캩 k v칳m캩n캩 dat mezi webov칳mi aplikacemi a servery, ale d치 se pou쮂셨at i pro jednoduch칠 datab치ze. M치 prost치 ale zato striktn칤 pravidla a tud칤 je jednoduch칠 zkontrolovat jeho spr치vnost. Jeden z jeho nedostatk콢 je, 쬰 nem치 podporu koment치콏콢 oproti XML, kter칠 tuto podporu m치. %\textbf{ TODO odkaz n캩kde na iso normu https://www.iso.org/standard/71616.html} %TODO bibtech na iso normu plus d치t emoji 游땛 t콏eba xetex ale to se pak cel칠 rozbije


\subsection{Pravidla}
\textbf{Key} neboli kl칤캜 dan칠ho objektu je v쬯y string a reprezentuje n치zev ur캜it칠ho atributu. \textbf{Value} p콏edstavuje hodnotu, kterou tento atribut nab칳v치 a m콢쬰 b칳t datov칠ho typu text, 캜칤slo, logick치 hodnota, null, dal코칤 objekt 캜i pole. Jednotliv칠 atributy jsou v쬯y odd캩leny 캜치rkou. Jako p콏칤klad je uveden JSON objekt z API modelov칠 hry, kter칳 popisuje hr치캜e, jeho vlastnosti a jeho rasu, reprezentovanou jako vno콏en칳 objekt.

\begin{listing}[H]
    \inputminted{json}{resources/code/standards/player.json}
    \caption{P콏칤klad JSON objektu}
    \label{code:json_player}
\end{listing}

V tomto JSONu m콢쬰me vid캩t v코echno, s 캜칤m se u tohoto datov칠ho form치tu m콢쬰me setkat. Jako prvn칤 atribut, tento objekt m치 \verb|"id":4|, kde id je kl칤캜 a 4 je 캜칤slo -- to zna캜칤, 쬰 tento objekt m치 sv콢j unik치tn칤 identifik치tor 4.

Na 6 콏치dku m콢쬰me vid캩t atribut \verb|"title":"Elf"|. Value je v tomto p콏칤pad캩 text, kter칳 pozn치me podle zaobalen칤 uvozovek. Tento 콏치dek v kontextu cel칠ho objektu zna캜칤, 쬰 se jedn치 o rasu postavy, kter치 m치 n치zev \textit{Elf}.

Atribut, kter칳 tento text zaobaluje, je \texttt{"race"}. Jedn치 se o p콏칤klad objektu, v tomto p콏칤pad캩 rasy, kter치 m치 sv칠 vlastnosti reprezentovan칠 pr치v캩 t칤mto objektem.

V atributu \texttt{"effects"} se nach치z칤 pole objekt콢. V tomto p콏칤pad캩 to jsou objekty obsahuj칤c칤 kl칤캜 s id rasy a jej칤m efektem, ke kter칠mu je p콏id치na tak칠 informace o tom, od jak칠 칰rovn캩 je tento efekt zp콏칤stupn캩n. Podobn캩 tak na 콏치dku 26 je jako value kl칤캜e \texttt{inventory} pole textov칳ch 콏et캩zc콢 zn치zor켿uj칤c칤 p콏edm캩ty, kter칠 hr치캜 vlastn칤.

D치le si m콢쬰me pov코imnout atributu \texttt{clazz} na 콏치dku 3, kter칳 m치 hodnotu \texttt{null}. To n치m zna캜칤, 쬰 tento konkr칠tn칤 kl칤캜 u objektu zat칤m nic neobsahuje. M콢쬰 se st치t 쬰 jen nebyl p콏i콏azen a v budoucnu n캩jakou hodnotu dostane.

A nakonec zde m치me na 콏치dku 29 atribut \texttt{dead} s hodnotou \texttt{false}. Tato hodnota zna캜칤 logickou hodnotu, kter치 m치 datov칳 typ boolean. V na코em p콏칤pad캩 se jedn치 o vlastnost, kter치 n치m 콏칤k치, zda je hr치캜 mrtv칳 (\texttt{true}) 캜i nikoli (\texttt{false}).


\section{XML}
Extensible Markup Language je jazyk prim치rn캩 ur캜en칳 na serializaci a p콏en치코en칤 dat, kter칳 je podobn캩 jako JSON 캜iteln칳 i 캜lov캩kem. Z치kladn칤 stavebn칤 blok je node, atributy jsou ulo쬰ny do p치r콢 kter칳m 콏칤k치me tagy. Za pomoc칤 sv칠 deklarace podporuje ur캜en칤 k칩dov치n칤 a r콢zn칠 verze. D칤ky XML Schema definition tak칠 podporuje celou 콏adu datov칳ch typ콢 a oproti JSONu podporuje i koment치콏e. Standardy spravuje spole캜nost W3C. %\textbf{fest fajny odkaz na w3c specifikaci do bibtex} %TODO bibtech na w3c


\subsection{Pravidla}
Na za캜치tku dokumentu je v쬯ycky XML deklarace, kter치 ur캜uje, o jakou verzi se jedn치 a jak칠 maj칤 znaky k칩dov치n칤.
Samotn치 data jsou zaznamen치na pomoc칤 p치rov칳ch tag콢, dohromady naz칳van칳m \textbf{element}, kter칠 se zapisuj칤 jako po캜치te캜n칤 (\texttt{<character>}) a ukon캜ovac칤 (\texttt{</character>}) tag, kde \textit{character} zna캜칤 n치zev atributu, podobn캩 jako \textbf{key} u JSONu. Hodnota atributu se p칤코e bu캞 mezi po캜치te캜n칤 a ukon캜ovac칤 tag, nebo p콏칤mo do tagu samotn칠ho (\texttt{<character id=4>}). Tzv. \textit{procesory} analyzuj칤 XML dokumenty a pos칤laj칤 d치le strukturovan치 data aplikaci, kter치 se vyu쮂셨치. Procesory m콢쬺u b칳t jak validuj칤c칤 tak nevaliduj칤c칤, p콏i캜em validuj칤c칤 mus칤 nalezenou chybu nahl치sit ale po콏치d mohou v parsov치n칤 pokra캜ovat.

\begin{listing}[H]
    \inputminted{xml}{resources/code/standards/player.xml}
    \caption{P콏칤klad XML dokumentu i se sch칠matem}
    \label{code:xml_player}
\end{listing}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/type-hierarchy.png}
    \caption{Hierarchie datov칳ch typ콢 v XML schema}%\cite{british_museum_2021}}
    \label{fig:xml_datatypes}
\end{figure}
%TODO odkaz na obr치zek v코ech mo쬹칳ch datov칳ch typ콢 https://www.w3.org/TR/xmlschema-2/type-hierarchy.gif a p콏칤mo ta str치nka https://www.w3.org/TR/xmlschema-2/#built-in-datatypes


%TODO n캩jak칳 odkaz p캩kn칳 nebo tak n캩co na xml asi idk co jsem t칤m tady cht캩l 콏칤ct
Tento XML dokument reprezentuje stejnou strukturu jako JSON popsan칳 v칳코e. Oproti n캩mu je v코ak roz코칤콏en o sch칠ma, ve kter칠m m콢쬰me ur캜it jeden z mnoha datov칳ch typ콢 \ref{fig:xml_datatypes} pro ka쬯칳 element (콏치dek 3) 캜i atribut (콏치dek 6 a 7). Kdy nen칤 sch칠ma specifikov치no, v코echny datov칠 typy jou br치ny za text. Velk치 zm캩na oproti JSONu tak칠 spo캜칤v치 v tom, 쬰 v칤me, o jak칳 objekt se jedn치 (콏치dek 23 a 48) -- m칤sto oby캜ejn칳ch slo쬰n칳ch z치vorek zde m치me element se jm칠nem \textit{character}, co je informace, kterou JSON neposkytuje.


\section{Shrnut칤}
V p콏edchoz칤 캜치sti byly pops치ny dva z치kladn칤 form치ty pro serializaci a deserializaci dat -- JSON a XML. Oba form치ty maj칤 sv칠 v칳hody a nev칳hody, kter칠 je t콏eba zv치쬴t p콏i v칳b캩ru vhodn칠ho form치tu pro konkr칠tn칤 pou쬴t칤.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
               & 캛itelnost & Jednoduchost & Rychlost & Skladnost \\
        \hline
        JSON   & 1         & 1            & 2        & 3         \\
        \hline
        XML    & 2         & 3            & 4        & 4         \\
        \hline
        Binary & 5         & 4            & 1        & 1         \\
        \hline
    \end{tabular}
    \caption{Porovn치n칤 JSON, XML a Binary }
    \label{tab:formats_comparison}
\end{table}

Tabulka \ref{tab:formats_comparison} srovn치v치 v칳코e zm칤n캩n칠 technologie podle n캩kolika krit칠ri칤, kter칠 jsou d콢le쬴t칠 pro v칳b캩r vhodn칠ho form치tu pro serializaci a deserializaci dat. \footnote[1]{Zn치mkov치n칤 jsem prov치d캩l 캜ist캩 podle vlastn칤ho uv치쬰n칤 vzhledem k tomu, co bude pro na코e pou쬴t칤 nejvhodn캩j코칤} \footnote[2]{Hodnocen칤 je vedeno jako zn치mka na 코k치le od 1 do 5 kdy 1 p콏edstavuje souhlas a 5 nesouhlas} Pro na코e 칰캜ely je pot콏eba, aby byl form치t jednoduch칳 a srozumiteln칳, ale po콏치d p콏im캩콏en캩 rychl칳. XML je pro na코e 칰캜ely moc komplexn칤 a v캩t코inou se pou쮂셨치 pro velk칠 a komplexn칤 struktury dat, co nen칤 n치코 p콏칤pad. Bin치rn칤 form치t je sice rychl칳, ale 코patn캩 se odhaluj칤 chyby a tak칠 je zd캩 v캩t코칤 probl칠m s univerz치lnost칤 serializeru a deserializeru mezi jazyky. JSON je pro n치s ide치ln칤, nebo콘 je jednoduch칳, rychl칳 a dob콏e 캜iteln칳, proto bude pou쬴t pro reprezentaci p콏enosov칳ch dat v na코칤 aplikaci.


\endinput